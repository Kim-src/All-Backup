📌 1. 2024-04-17 강의
- 20240417-자바 수업(정리완료)

자바 기초
- Math
- random()
- if(), else, else if()
- 스캐너


2024-04-17 20:30 2교시 강의 내용

버퍼(buffer)라는 메모리 공간에 타이핑한 내용이 기억됩니다.
그리고 엔터 키를 입력하면 엔터만이 기억되고 저장되어있던 내용이 출력됩니다.
이 저장된 엔터키를 버퍼 공간에서 비워줘야 됩니다.


플러시(flush; 청소) 기능 -> 플러시는 변기 내릴 때

자바에서는 같은 폴더 내에 동일한 이름의 클래스를 생성할 수 없습니다.

Ctrl + Shift + O (알파벳 O)

스캐너를 사요하는 방법
왜 import를 사용해야 되는지

📌 2. 2024-04-18 강의
- 20240418-자바 수업(정리완료)

* 반복문

반복문은 특정 행위를 반복시키는 함수를 의미합니다.
반복문은 몇 회 반복하는지 중요합니다.
for while do while문 등이 존재합니다.
그런데 Java에서는 do while 반복문은 잘 사용되지 않습니다.
참고로 do while 반복문은 게임 개발에 사용되는 C언어 코드에서는 사용되기도 합니다.

for 반복 횟수
while 반복 횟수 X, 조건대로 반복

반복
for (초기값 선언; 조건식; 증감식) {실행코드}

이중 루프
다중 for문
평면 : x * y

구구단
별짓기

오류 1%마다 5점감점 인사평가

생각하는 힘 기르기
첫 번째 홈페이지 4개월
두 번째 홈페이지 3개월 등
점점 시간이 줄어야 됨

* 별짓기
루프 개수는 상관없음
주석
자바 파일로

📌 3. 2024-04-24 강의
- 20240424-자바 수업(정리완료)

2차 배열은 행렬을 표현할 때 사용

수학의 행렬 구조를 표현함에 있어서 2차 배열이 용이하기 때문에
행렬의 구조를 2차 배열로 표현한 것임
(2차 배열 = 행렬이 아님; 2차 배열 != 행렬)

행렬은 2차원 배열이 될 수 있음
2차원 배열은 행렬이 될 수 없음

이미지는 행렬 구조로 되어 있음

배열 안에 배열을 넣음
array in array

배열은 행렬이 아닌 이유
x축의 배열과 y축의 배열이 있을 때
y축의 배열의 개수는 각각 달라도 됨
그렇기 때문에 배열은 꼭 행렬이 아님

x좌표
y좌표
방향
시간
4차 배열로 발전

캐릭터
아이템
스킬
등

행 분류
열 분류에 대한 상세 데이터

1명의 국영수 점수
2명의 국영수 점수
3명의 국영수 점수

-----

📌 4. 2024-04-25 강의
- 20240425-자바 수업(정리완료)

숙제
3명 이상의 학생
과목 : 국어, 수학, 영어

각 학생에 대한 점수는 키보드 입력으로 받아라
각 학생이 받은 점수를 학생별로 출력
학생들 중에서 최고점자와 최저점자를 출력


* 객체 정의
객체는 현실에서 존재하거나 추상적으로 존재한다고 알고 있다는 것들 중에서 프로그래밍으로 만들 수 있거나 프로그래밍으로 만들만한 가치가 있는 것

* 객체지향 프로그래밍
작은 단위의 객체를 모아서 큰 단위의 애플리케이션을 생성하는 것

* 객체
- 성능
- 무게, 최고 속도, 가로 길이, 세로 길이

* 클래스
- 현실의 객체를 프로그래밍 언어로 설명하려고 생성한 것
- 클래스는 객체의 설계도, 설명서
- 머릿속에 있는 아이언맨 제작 방법, 책상 제작 방법 등을 컴퓨터에게 전달하려는 것

* 메서드
- 기능
- 가다, 서다, 주유하다, 가속하다, 감속하다

* 인스턴스
- 클래스의 정보를 가지고 현실 세계에 만들어 낸 것

* 질문 : 객체와 클래스와 인스턴스의 관계에 대해서 설명하세요.
- 객체는 현실에 존재하는 어떠한 것 중 프로그래밍화 할 수 있는 것
- 클래스는 객체를 설명한 것이지 실제로 생성된 것은 아님
- 인스턴스는 클래스를 토대로 어떠한 것으로 만들어진 상태

* 메모리
- 저장, 기억
- 자바가 기억하려는 데이터 3개, 사용자가 사용하려는 데이터 2개
- 스태틱
- 힙 - 인스턴스가 올라가는 곳 - 힙에 올라오는 것만 사용자가 접근 가능

* CPU
- 연산, 행동

* make
- 객체의 선언
- 클래스의 객체화
- 인스턴스화(make instance)d

* 객체화
- Class를 선언하여 heap 메모리 영역에 공간을 부여하여 사용할 수 있도록 저장하는 것

* Scanner
- Scanner 클래스 객체는 이미 있는데 왜 계속 생성자 메서드 new로 생성시켰을까?
- heap이라는 메모리 영역에 공간을 형성하고 사용하기 위해 Scanner를 생성자 메서드를 이용하여 선언
- 클래스를 객체화 한 인스턴스
- 내가 Scanner를 만들거예요
- 어디에? heap에
- 무엇으로? new Scanner(System.in)으로
- scan 변수는 즉 인스턴스

* 클래스
- 특정한 지정 공간에 클래스가 갖고 있는 변수와 메서드를 호출할 수 있음
- new : 새로운 공간을 달라고 요청하는 것 - 생성자 메서드
- . : 클래스가 갖고 있는 변수와 메서드를 가져올 수 있는 것

📌 5. 2024-04-29 강의
- 20240429-자바 수업(정리완료)

삼항연산자 대신 if else 조건문 사용

인풋이 1이면 성인 아니면 어린이 등 ~이면 ~아니면의 조건이 있을 때 삼항 연산자 사용됨

void 리턴 없다는 것

리턴 있으려면
int String double 등등

소괄호 있으면 메서드
소괄호 없으면 변수

리턴하기 싫으면 void
void일 때는 return 키워드가 없어야 됨


리턴 있고 파라미터 있음
Arrays.toString(배열);
리턴 있고 파라미터 없음
Math.random();
리턴 없고 파라미터 있음
print("안녕") / println("안녕");
리턴 없고 파라미터 없음
println();


보통 파라미터는 4~5개
파라미터가 더 많아지면 한꺼번에 객체로 묶어버림


생성자 메서드는 이름이 클래스의 이름과 동일해야 됨
Car car = new Car();


생성자 메서드 : 
객체를 생성할 때 최초/마지막으로 호출되는 것

객체를 만들 때 생성자를 선언하지 않으면
클래스를 컴파일하는 과정에서 생성자를 자동으로 생성함

생성자는 호출을 못함
생성자는 객체를 선언할 때만 할 수 있음
따라서 생성자는 return 타입이 필요가 없음


C++ 은 클래스 없이도 ? 만들 수 있음
객체를 생성하고 객체 메모리 해제하는 것을 개발자가 직접 해야됨


Java는 객체의 생명주기를 개발자가 컨트롤 할 수 없음

생성자는 객체를 만들 때만
리턴 타입이 필요 없음
그래서 생성자를 메서드라고 쉽게 부를 수 없음


생성자는 리턴 타입이 없기 때문에 메서드라고 부르기 거석함



클래스는 . 으로 접근함



다음 시간
접근 배열자?

페이즈1
상속

페이즈2
추상화 

페이즈3
인터페이스(상속을 이해해야 추상화 인터페이스를 이해할 수 있음)

📌 6. 2024-04-30 강의
- 20240430-자바 수업(정리완료)

ㅁ getter 및 setter의 의미와 사용하는 이유 = public
getter : 값을 주는 메서드 : 값 반환 - return 있음 parameter 없음 - 값을 줘야 됨
setter : 값을 받는 메서드 : 값 입력 - return 없음 parameter 있음 - 값을 돌려줄 필요가 없음

다른 것이 없는데 왜 getter 및 setter를 사용해야 되냐?
그냥 public이면 될 것 같은데
이유1 : 보안 때문에
이유2 : 데이터를 주고 받는 것에 대해 제한을 둘 수 있음
무조건 있지는 않아도 되나? GPT로 설명 보충

두번째음절부터 대문자
이 행위의 이름이
가멸치기?
가멸치?

우클릭
source
gestters ~
select all
generate


* 접급 제한자
클래스에 접근할 수 있는 권한을 부여
= 캡슐화
= 접근 제한자를 사용하여 

* 접근 제한자
= 클래스의 변수 또는 메서드를 외부에서 접근하여 사용하려고 할 때 그 접근에 대한 제한을 둘 수 있는 방법

* 캡슐화
= 접근 제한자를 사용하여 객체의 변수 또는 메서드 사용에 제한을 두는 것

* 접근 제한자의 종류
public : 모두 open
protected : 같은 패키지 상속관계(자식)
(default : 같은 패키지) default는 몰라도 됨
private : X : 데이터 클래스의 모든 멤버 변수는 무조건 private 접근제한자로 선언


분야 정하기 : 웹 개발, 게임, 서버, 임베디드 개발자 등
언어 정하기
최신 기술 동향
필수 요건 : 아주 잘해야 됨
우대 조건 : 기술 1~2개 할 줄 알아야 됨 → 경쟁력 가지려면
기술 블로그 등 보여줄 것들 준비(프로젝트, 포트폴리오 등)
면접 준비 : 다음 질문에 대한 의도가 있어야 됨

꿈을 이 회사에서 펼치고 싶다.
왜 이 회사냐?
~



ㅇ 메서드 오버라이드
ㅇ 메서드 오버로드(오버로딩)
- 대표적 오버로드 = print
- 실제로 print의 파라미터는 10개 정도?(기본 타입)
- 생성자 메서드도 오버로드 가능 - 기본 생성자는 파라미터가 없음

Java에서 앞음절이 대문자면 클래스

📌 7. 2024-05-02 강의

클래스의 구조를 파악

클래스 변수,
클래스 메서드,
멤버 변수,
멤버 메서드
인스턴스 변수,
인스턴스 메서드
추상 메서드,
추상 클래스



상속

클래스 변수
클래스 메서드

public 접근제한자 배움

void 리턴 타입 배움

static이란?


멤머 변수
멤버 메서드

인스턴스 변수
인스턴스 메서드

Car car 중
인스턴스는 car
변수인데 클래스가 담겨 있어서 인스턴스
점으로 연결(호출?) 가능
객체를 선언해야 사용할 수 있음

변수 중에 일반 변수와 클래스 변수가 있는데
둘의 차이를 설명해보시오.


* 정적 키워드
클래스를 변수화하지 않아도 객체를 사용할 수 있음


System도 클래스고 out도 클래스임

주인공의 키워드 = static
static = 정적 키워드
static은 변수에도 메서드에도 붙일 수 있음
static을 변수에 붙이면 클래스 변수
static을 메서드에 붙이면 클래스 메서드


* 개념
인스턴스 변수/메서드
- 설명(강의 내용 못적음)(강의 15분째 정도)

클래스 변수/메서드
- 클래스를 객체화 하지 않고 클래스를 통하여 호출 가능한 변수 또는 메서드
- System.out.println();
- out은 클래스 변수 : 클래스를 통해서 직접적인 호출이 가능하기 때문에
- 이것을 가능하게 하려면 method 앞에 static을 붙이면 됨
- static을 사용하기 위해서는 접근제한자가 public 또는 private이어야 되나?


정적 변수/메서드
 = 실제 이름은 클래스 변수/메서드



* heap과 static
public class Car {
	public int price;
	public static String company;
}

price가 메모리에 올라갈 떄는 객체화 할 때
- 인스턴스 생성될 때
static 메모리에 컴파일 될 때 통째로 

static은 유일하게 공간 안에 값을 끌어옴
이 방식은 메모리에 저장된 데이터 주소를 참조하는 개념과는 다름

static은 한 번 메모리에 올라가면 해당 메모리 공간을 점유하고 없어지지 않음

그래서 static을 남발하면 안됨
static은 공유 메모리다?

static 변수는 상수 생성할 때 사용됨
상수 = 고정값 = 파이 등
static final이라고도 사용됨
final은 한 번 선언하면 값을 변경할 수 없음


메모리에 print를 걸어두고 호출해서 사용


main에 static이 있는 이유
프로그램이 없어지기 전까지 쉽게 사용하기 위해

컴퓨터 시스템은 개발자가 생성한 클래스 이름은 모름
(사람이 타이핑 했을 뿐임)
그래서 main?
그래서 main을 하나만 만들 수 있음
main을 여러 개 만들면 프로그램의 실행 시점을 찾기 어려움
메모리에 올라가 있지 않으면 ~
static을 붙이지 않을거면 main 이름이 여러 개 있어도 상관 없음
static을 붙일것이면 main을 하나만

static이 붙어있는 main 여러개면 Eclipse의 경우 어떤 static이 붙어있는 main 메서드를 사용할지 물어보는 알림창이 팝업됨


static 

Car라는 클래스파일이~

this
- 인스턴스임 (변수가 아니라)
- 메모리에 올라가고 사용 가능

setter
- 인스턴스가 만들어진 뒤 사용 가능



----------2교시----------

상속의 경우
클래스의 형태를 정확히 이해해야 사용성이 좋음
그렇지 않고 사용할 경우 심각한 에러가 발생될 수 있음

* 상속
코드 중복 제거
간결성
재사용성 높아짐
다형성


부모클래스 = 상위클래스
자식클래스 = 하위클래스



기능만 보고서는 부모 클래스를 알 수는 없음
왜냐하면 데이터 타입부터 다를 수 있기 때문


기능적으로는 크게 어렵지 않음


------

코드가 적용되려면 저장해야됨 왜?
저장하면서 .java가 .class로 변환 컴파일 됨
컴파일이 되어야~
=> 저장해서 컴파일 시켜야 에러가 없어진다.

--------


클래스 간의 상속
클래스 인터페이스 간의 상속


페이즈1
상속

페이즈2
추상화 

페이즈3
인터페이스(상속을 이해해야 추상화 인터페이스를 이해할 수 있음)







1. 주제
- GoogoodanMaster.java
- 구구단 곱셈의 정답을 빠르게 입력하여 점수를 획득하는 프로그램

2. 주제를 선정한 이유
- 암산 실력 및 순발력 증진
- Java의 random 메서드 복습
- Java의 Scanner 클래스 복습
- Java의 for 반복문 복습
- Java의 boolean 타입 학습
- Java의 시간 관련 알고리즘 학습

3. 어떠한 기능을 가진 프로그램을 만들지
- 자동으로 랜덤의 구구단 곱셈식 출력
- 주어진 시간 내에 출력된 곱셈식의 정답을 맞추면 점수 획득(true일 경우 score++)
- 주어진 시간 내에 출력된 곱셈식의 정답을 맞추지 못할 경우 점수 출력(점수 = 누적된 score값)

4. 향후 추가하고 싶은 기능
- 데이터베이스에 획득한 점수값과 점수 획득자명 저장
- 데이터베이스에 저장된 정보를 기반으로 점수 랭킹 출력
- 랭킹에는 점수 내림차순에 따른 등수 오름차순, 점수 획득자, 획득한 점수 정보 포함

5. 참고 사이트
https://blog.naver.com/PostView.nhn?blogId=highkrs&logNo=220283709171


추상화
인터페이스
컬렉션
예외처리
String 관련

📌 8. 2024-05-03 강의
- 20240503-(정리완료)자바 수업(추상화, 인터페이스)

** 생성자
** 오버라이드

자식 상속자 호출할 때 부모 클래스를  복사

그 다음 오버라이드

메서드의 오버라이드
---

메서드 오버라이드
부모가 가진 메서드를 자식 클레스에서 재정의하여 사용하는 것

메서드의 형태는 그대로 두고 메서드의 구현 내용을 다시 고쳐 사용하는 것을 의미


getinfo는 그대로인데 내용만 변경?

메서드의 목적과 형태는 그대로인데
안에 있는 내용 수정


Object 메서드(?)

equals
hashcode
toString을 가장 많이 사용함


@ 어노테이션
자바에서 변수가 역할 기능 상태를 수식으로 부여하는 것



----


추상화

추상화 클래스
추상화 메서드를 지니는 클래스
추상화 메서드를 지니기 위한 클래스

추상화 메서드
정의만 되고 구현되지 않는 메서드



-----


변수가 저장되는 위치와
값이 저장되는 위치가 서로 다름


콜바이밸류
콜바이래퍼런스

넘어갈 때 값이 넘어가니 주소가 넘어가니

Java는 전부 콜 바이 밸류
Java는 진짜 주소를 몰라서 클론이 안됨
(그냥 같은 집에 사는 하숙생 더 만든 것임)

C 언어는 포인터?가 있어서 주소가 같은 복제품을 만들 수 있음


객체는 공간 안에 있는 것이어서
객체 주소를 바꾸려면 객체를 새로운 주소로 바꿈
집의 주소가 바뀌려면 이사를 가야됨
객체 주소를 바꾸려면 재정의

가변형 고정형



----
추상화 클래스 강의 끝
----

상속 안되는거
private(그래서 getter setter만)(부모만)
static 선언된 것(부모만)
-----
인터페이스 시작

상속이지만 결이 다름
-----

클래스 상속
1. 타입을 상속 = 다형성
2. 변수나 메서드 상속

인터페이스의 경우
1. 기능 


static
상수

클래스-인터페이스 implements
클래스-클래스 extends
인터-인터 entends 확장


-----

인터페이스는 추상화 클래스보다 훨씬 많이 사용됨

인터페이스 사용 목적
1. 기능의 정의(또는 기능의 강제)
- 같은 목적을 지닌 클래스들에게 동일한 이름의 기능을 부여(리모콘의 버튼별 색깔을 생각)(자동차의 엑셀 브레이크 시동)
- 동일한 목적의 클래스라면 동일한 기능을 부여
- 기능의 통일화
- ~의 간결화


~20240503 interface

📌 9. 2024-05-07 강의
- 20240507-(정리완료)자바 수업(제네릭, wrapper)


작성된 코드가

구구단 자체 문제를 프로그램 형태

list

-----
collection을 배우기 위해

래퍼 wrapper 클래스
- 일반 클래스를 감싸서?

클래스화 된 것

3교시 제너릭

-----
1, 2교시 wrapper 클래스
-----

0. 사용 방법
int a = 15; 말고
Integer a = 15;

1. 형변환
String str = "12";
int a = (int)str;

String 타입을 ~
wrapper 클래스는 형변환을 가능하게 해줌

2. DataBase로부터의 값을 받을 때 사용
- DB는 값이 전부 객체


문자열 → 정수 변환에서
"123"은 정수 변환 가능
"12.3"은 정수 변환 불가능 - 왜냐하면 '.'은 문자이고 int는 문자를 인식하지 못하기 때문에

wrapper 클래스는
autoboxing 기능과 unboxing 기능이 있음?

int a = 15; 말고
Integer a = 15;
그래서
int b = a;는 데이터 형태가 다르기 때문에 틀림, 그런데 wrapper 클래스의 unboxing 기능 때문에 에러가 나지 않음



형변환 하는 공통 메서드


parse + 타입
parseInt
parseDouble
parseLong
parseBoolean 등등

-----wrapper 클래스 내용 정리-----
wrapper 클래스는 형변환 하는 애.
10진수를 2진수로
16진수를 2진수로 등

그런데 값 자체를 비교하려면
일반 데이터 타입 말고 '객체 타입'으로 비교해라.

정수형 wrapper 클래스를 가장 많이 사용 함
-----wrapper 클래스 내용 끝-----



-----3교시 제너릭-----
제네릭(Generic)이란 무엇인가요?
- 제너릭은 '컬렉션' (오답)
- 제네릭은 특정 클래스가 다뤄야 하는 데이터 타입을 그 객체가 생성될 때 외부로부터 정의받는 기능
- 다용도 그릇(무엇을 담으면 '무엇 그릇'이 됨)
- 외부로부터 그릇의 용도가 적용됨(동적임)
- 제네릭을 채택한 것이 컬렉션임

어떠한 것을 생성?
형식상의 제네릭 키워드는 있음
예를들면<E>를 해서 Element만 들어갈 수 있는 것이 아님
그냥 껍데기에 대한 약속임


// 제네릭이 뭐예요?
// 제네릭은 하나의 저장 클래스를 선언하면서 다양한 데이터를 담는 그릇으로 만들 수 있습니다.
// 그래서 데이터 클래스의 사용 효율성을 높일 수 있습니다.


5-8
컬렉션
리스트
~

5-9
예외처리


월요일부터
db





안녕하십니까,
코리아IT 신촌점 평일반 수강생 김창성입니다.

개인 개발 프로젝트 결과물을 제출하려고 합니다.
프로젝트명은 '순발력 구구단 게임(GoogoodanGame)'입니다.


※ 1. 첨부파일 설명
첨부된 압축 파일 내에는 2개의 .java 파일이 있습니다.
1. GoogoodanGame.java : 부연 설명 없이 소스 코드만이 작성되어 있는 파일입니다.
2. GoogoodanGameReadme.java : 소스 코드뿐만 아니라 부연 설명(주석)이 작성되어 있는 파일입니다.

아래는 관련 깃허브 링크입니다.
https://github.com/Kim-src/Study-Java/tree/main/sample13/src/kr/it/assignment


※ 2. 결과 보고서 설명
프로젝트 결과물에 대한 기능 설명 및 소감은 블로그 글에 작성하였습니다.
혹시나 꼭 문서화(자료화)를 하셔야 되는 상황이라면 문서화해서 보내드리겠습니다.

아래는 깃허브 블로그 글 링크입니다.
https://kim-src.github.io/posts/%EA%B5%AC%EA%B5%AC%EB%8B%A8-%EA%B2%8C%EC%9E%84-%EC%A0%9C%EC%9E%91-%EB%B0%A9%EB%B2%95-%EB%B0%8F-Java-Timer,-TimerTask-%ED%81%B4%EB%9E%98%EC%8A%A4/


항상 감사합니다.
김창성 올림

📌 10. 2024-05-08 수업
- 20240508-자바 수업(정리완료)

★★★★★ 강의 마지막 부분(22:18)
아래 정리

-----1교시-----

컬렉션

Collection Framework
자료구조 집합

List
Set
Map

리스트
- Collection Framework임

셋
- Collection Framework임

맵
- Collection Framework이 아님
- ?? 인터페이스를 상속받지 못해서
- 컬렉션 클래스가 아니라 그냥 맵입


자료구조의 예시
data sturcture
list
set
map
stack
queue


스택 큐는 요새 잘 사용 안함
큐는 네트워크하고 관련있긴 함(sender, lister)



list
set
map

세가지를 많이 사용함
그중에서도 set은 많이 안함(일반적으로는 할 일 없음)
컬렉션 = 자료구조 집합



1. List
- 인터페이스입니다.
- 리스트 구조에 정의한 기술명세서
- ArrayList
- LinkedList

리스트를 상속받았기 때문에 기능의 명칭은 비슷합니다.
하지만 내부를 구현하는 방법이 다릅니다.
만약 같다면 굳이 두 가지로 구분될 필요가 없습니다.

1-1. ArrayList
- 저장용으로 많이 사용됨
- add 할 때 사이즈가 늘어나면 새로운 배열을 생성해서 치환합니다.
- 내부구조가 배열로 구성되어 있습니다.

1-1-1.
- 선언 시 배열의 길이를 작성할 필요가 없습니다. 'int[3]' 등을 작성할 필요가 없습니다.
- 이유는 넣는 만큼 배열의 길이가 변경(증가)되기 때문입니다.

1-1-2.
- 삭제 또는 삽입이 가능합니다.
- 일반 Array는 한 번 선언되면 배열의 길이를 수정할 수 없습니다.

1-1-3.
- '단순 삽입' 속도가 빠릅니다.

1-1-4.
- 그런데 삭제, 삽입 속도는 느립니다.
- 그래서 데이터의 삽입 또는 삭제가 빈번할 때는 다른 방법을 찾는 것이 좋습니다.
- 왜 느릴까?
- [5, 3, 7]의 [1]에 [11] 삽입하려면 모든 인덱스가 뒤로 밀려야되기 때문입니다.


1-2. LinkedList
- 삽입과 삭제가 빈번한 기능을 구현할 때 사용
- 연산용으로 많이 사용됨

- 저장할 때 객체를 이용하기 때문에 삽입 또는 삭제 속도가 빠릅니다.

- 객체
- node
- new Address
- value
- nextAddress
- node는 value의 앞과 뒤의 주소를 갖고 있음
- 주소를 이용된 연결고리가 있기 때문에 인덱스 탐색이 쉬움
- 그래서 정렬이 빠름
- 대신 '단순 삽입'의 경우 앞뒤 주소를 알아야 되기 때문에 느림
- 1만번 이하는 LinkedList가 더 빠름
- 근데 10만개 등 이상으로 되면 ArrayList가 훨씬 빠름(단순 저장, 처리 빠름)
- LinkedList '중간 삽입' 또는 '중간 삭제' 빠름

특이사항
- 순서는 있는데 인덱스는 없음
- 순번에 의해서 결정된 순서가 아니라 앞뒤의 주소를 참조된 순서이기 때문입니다.
- 컬렉션 리스트에서 LinkedList는 주소에 의해서 묶여있는 것이지 순서에 의해서 묶여있는 것이 아닙니다.
- LinkedList는 index 대신 node가 있는 것입니다. (배열을 사용하지 않고 node라는 객체를 이용하여 체인 형식으로 앞뒤를 연결하여 데이터를 저장함)


-----2교시-----


(간단히 말만)
(Set 사용하는 경우가 거의 없음)
Set
- 인덱스가 없기 때문에 '중간 삽입' 또는 '중간 삭제'가 불가능함
- 그냥 값으로만 삭제해야됨
- 1을 100번 넣어도 1이 하나만 삽입되어있음
- 중복을 허용하지 않기 때문입니다.
- 첫 번째 포함된 데이터 이외의 중복 데이터는 무시합니다.

- 순서가 없기 때문에
- 값이 ~


-----

배열을 리스트로
리스트를 배열로 가능
- 이클립스에 구현


---리스트---
제네릭을 이용해서 어떤 데이터를 넣을지 선언
jdk1.7

삽입은 add
중간삽입은 index add
등등 eclipse 참고

↑ 리스트의 기본적인 사용 방법



-----3교시-----


Map은 Spring에서 많이 사용됨
Map과 비슷한 방식으로 데이터 저장 방식이 비슷한 애들이 많음

Map 데이터 저장 형태
<Key, Value>
key 및 value에 대한 데이터 둘 다 제네릭에 넣어야 됨
그래서 Hashtable로 데이터를 저장하게 됨

Hash 값이란
- 객체 형태의 애들은 주소가 있음
- Java에서 제공한 주소는 hashcode임
- hashcode는 16진수입니다.

객체는 두 가지로 비교할 수 있습니다.
1. 주소
2. 값
같은 객체인지 아닌지는 주소와 값으로 비교합니다.
주소는 hashcode입니다.

--hash 충돌 현상--

Apple a = new Apple();
Apple b = new Apple();
a와 b의 apple의 주소는 달라야 됨
a.set(5);
b.set(6);

그런데 아주 가끔 hash 주소값이 같아져 버리는 경우가 있습니다.
그래서 값도 비교해야 됩니다.
만약 값도 같으면 두 객체를 동일하다고 판단합니다.(이런 경우는 거의 없음)

--hash 충돌 현상--


--Map의 종류--

1. HashMap(가장 많이 사용됨)
- 순서가 없습니다.(Map에서 순서를 필요로 하는 경우는 거의 없습니다.)
- key value가 쌍으로 이루어진 데이터 형태입니다.
- key는 중복이 불가능하기 때문에
- key만 알면 데이터를 찾을 수 있기 때문에 순서는 중요하지 않습니다.
- 그리고 hash (주소(?))값으로 데이터가 저장됩니다.

key 중복 시
apple, 5
apple, 4
apple, 6
나중에 들어온 데이터의 value 값으로 key 데이터를 치환해버립니다.
5에서 4로, 4에서 6으로 치환합니다.
최종적으로 apple의 key가 6으로 설정됩니다.
value update

중간 삽입, 삭제 x
Map은 데이터를 쌍으로 집어넣기 때문에 수정하는 속도가 List보다 훨씬 느림
그럼 언제 빠를까?
데이터를 찾을 때는 겁나 빠름

2. LinkedHashMap
- 앞뒤 관계가 있고 순서가 있는 HashMap
- 하지만 인덱스는 없습니다.

3. TreeMap
- 거의 사용하지 않음(잊어버려도 됨)



★★★★★ 강의 마지막 부분(22:18)

강의 정리
자료구조의 집합
리스트 겟 셋?

list

set은 리스트와 비슷하나 순서가 없음 (중간 삽입 중간 삭제가 없음)
그리고 set은 중복을 허용하지 않기 때문에 처음 들어온 데이터를 제외하고 나머지는 무시함
그래서 중복 삭제를 위해서 사용하게 됨
사용자 입장에서는 잘 사용하지 않게 됨

map은 key와 value로 이루어져 있음
검색에 있어서는 빠름
key의 중복을 허용하지 않음
put을 넣었을 때 엑센트?

iterator 내부 커서
Map에는 없고 List와 Set만 갖고 있음



-----다음 시간-----
리스트 가지고 예제를 만들어 볼 것임
String
예외처리
part2로 넘어가고 Java 수업도 마침

월요일
HTML
CSS

📌 10-1. 2024-05-08 수업
- 20240508-자바 수업(창성 정리)(정리완료)

2024-05-08 수업

★★★★★ 강의 마지막 부분(22:18)
컬렉션은 자료 구조의 집합입니다.
대표적으로 리스트, 셋, 맵이 있습니다.
리스트는 데이터를 저장하는 것으로 배열과 비슷합니다.
하지만 배열은 데이터를 삽입할 때 데이터 크기, 데이터 수정, 데이터 삭제의 제약이 있는 편입니다.
이와는 달리 리스트는 데이터 크기, 데이터 수정, 데이터 삭제에 대한 제약이 없는 편입니다.
///
ArrayList는 데이터를 삽입하는 대로 크기가 증가합니다.
리스트는 중복을 허용합니다.
리스트는 데이터를 순차적으로 저장 또는 삭제할 때는 속도가 빠른 편입니다.
그러나 임의로 데이터를 중간에 삽입 또는 삭제할 때는 속도가 느린 편입니다.
이것을 보완하기 위해 출시된 것이 LinkedList입니다.
///

LinkedList의 경우 10만 건 이상의 데이터에 대한 단순 삽입, 순차 삽입, 순차 삭제는 ArrayList보다 느립니다.
데이터 처리가 10만 건 이하일 경우는 오히려 LinkedList가 ArrayList보다 빠르기 때문에
소량의 데이터 작업일 경우 LinkedList를 사용하는 것이 더 효율적일 수 있습니다.
하지만 그럼에도 LinkedList를 사용하지 않는 이유는 불특정 데이터를 생성할 시 처리량이 10만 건 이상이 될 수 있기 때문입니다.
///

LinkedList의 경우 데이터 처리량이 10만 건 이상 정도가 되면 순차 삽입 또는 순차 삽입의 속도가 ArrayList보다 느립니다.
따라서 많은 양의 불특정 데이터를 다루는 프로젝트의 경우 ArrayList를 사용하는 것이 더 효율적일 가능성이 큽니다.
대신 중간 삽입 또는 중간 삭제가 빈번한 데이터 처리 과정일 경우 일부 데이터를 LinkedList로 이동시켜서 처리시키면 데이터 처리 효율이 좋아지고 속도가 빨라집니다.
리스트는 배열과 마찬가지로 데이터 구조에 인덱스가 있기 떄문에 순차적인 데이터 처리가 가능합니다.
///

셋은 리스트와 비슷한 기능을 제공하지만 인덱스가 없고 데이터의 순서가 없습니다.
그래서 데이터를 삽입 또는 삭제할 수는 있지만 데이터의 임의 삽입/삭제(중간 삽입/삭제)는 불가능합니다.
그리고 셋은 리스트와는 다르게 중복을 허용하지 않습니다.
그래서 중복된 데이터가 삽입될 경우 초기 데이터를 제외한 나머지 데이터는 처리되지 않고 무시됩니다.
따라서 셋은 중복 데이터를 삭제할 시 사용하게 됩니다.
하지만 셋은 실무적으로 자주 사용되는 것은 아닙니다.
///

맵은 key와 value 쌍으로 구성되어 있습니다.
그래서 데이터 저장/삭제 속도가 느린 편입니다.
하지만 key라는 고유 값으로 데이터를 탐색하기 때문에 검색 속도는 매우 빠른 편입니다.
따라서 제작하려는 프로그램의 종류가 데이터를 검색하는 것이거나 데이터 탐색 기능이 빈번하게 요구되는 것인 경우 검색을 위해 데이터를 맵 위에 삽입하는 경우 상당히 빠른 퍼포먼스를 발생시킬 수 있습니다.
///

맵은 key의 중복을 허용하지 않습니다.
key가 중복될 경우 value값이 업데이트 되는 현상이 있지만 put을 넣었을 때 putIfAbsent 메서드를 사용하면 key 중복을 아예 무시할 수 있습니다.
///

리스트, 셋, 맵 모두 contains 메서드가 있기 떄문에 데이터가 중복되는지 탐색하는 기능이 있습니다.
contains key/value가 있고 contains라는 메서드가 각각 존재합니다.
중복 데이터를 찾는 데 용이하게 사용 가능합니다.

iterator
리스트의 경우 출력하는 방식이 다양합니다.
리스트/셋은 iterator라는 내부 순환 커서가 있어서 iterator를 이용하여 데이터를 출력할 수 있습니다.
interator의 경우 map에는 없습니다.
컬렉션을 상속받은 리스트 및 셋만 iterator가 있습니다.
그래서 리스트 또는 셋을 출력할 경우 인덱스가 있다고 하더라도 Java는 iterator를 이용한 출력 방식을 추천합니다.

하지만 데이터 처리를 하다보면 인덱스의 존재를 알아야 될 경우가 있습니다.
그럴 경우 리스트에 값을 삽입하고 인덱스를 이용하여 데이터를 출력하는 방식을 사용하면 됩니다.
즉, 데이터 출력 방식은 개발자의 선호도 또는 필요에 따라 선택하면 됩니다.
하지만 반복문이 증가되면 데이터 처리 속도의 차이 정도가 커질 수 있습니다.
그러므로 단순 루프나 단순 출력 기능의 반복문을 사용할 경우에는 리스트나 셋은 iterator를 이용하여 출력하는 것이 더 효율적일 가능성이 큽니다.










-----1교시-----

컬렉션

Collection Framework
자료구조 집합

List
Set
Map

리스트
- Collection Framework임

셋
- Collection Framework임

맵
- Collection Framework이 아님
- ?? 인터페이스를 상속받지 못해서
- 컬렉션 클래스가 아니라 그냥 맵입


자료구조의 예시
data sturcture
list
set
map
stack
queue


스택 큐는 요새 잘 사용 안함
큐는 네트워크하고 관련있긴 함(sender, lister)



list
set
map

세가지를 많이 사용함
그중에서도 set은 많이 안함(일반적으로는 할 일 없음)
컬렉션 = 자료구조 집합



1. List
- 인터페이스입니다.
- 리스트 구조에 정의한 기술명세서
- ArrayList
- LinkedList

리스트를 상속받았기 때문에 기능의 명칭은 비슷합니다.
하지만 내부를 구현하는 방법이 다릅니다.
만약 같다면 굳이 두 가지로 구분될 필요가 없습니다.

1-1. ArrayList
- 저장용으로 많이 사용됨
- add 할 때 사이즈가 늘어나면 새로운 배열을 생성해서 치환합니다.
- 내부구조가 배열로 구성되어 있습니다.

1-1-1.
- 선언 시 배열의 길이를 작성할 필요가 없습니다. 'int[3]' 등을 작성할 필요가 없습니다.
- 이유는 넣는 만큼 배열의 길이가 변경(증가)되기 때문입니다.

1-1-2.
- 삭제 또는 삽입이 가능합니다.
- 일반 Array는 한 번 선언되면 배열의 길이를 수정할 수 없습니다.

1-1-3.
- '단순 삽입' 속도가 빠릅니다.

1-1-4.
- 그런데 삭제, 삽입 속도는 느립니다.
- 그래서 데이터의 삽입 또는 삭제가 빈번할 때는 다른 방법을 찾는 것이 좋습니다.
- 왜 느릴까?
- [5, 3, 7]의 [1]에 [11] 삽입하려면 모든 인덱스가 뒤로 밀려야되기 때문입니다.


1-2. LinkedList
- 삽입과 삭제가 빈번한 기능을 구현할 때 사용
- 연산용으로 많이 사용됨

- 저장할 때 객체를 이용하기 때문에 삽입 또는 삭제 속도가 빠릅니다.

- 객체
- node
- new Address
- value
- nextAddress
- node는 value의 앞과 뒤의 주소를 갖고 있음
- 주소를 이용된 연결고리가 있기 때문에 인덱스 탐색이 쉬움
- 그래서 정렬이 빠름
- 대신 '단순 삽입'의 경우 앞뒤 주소를 알아야 되기 때문에 느림
- 1만번 이하는 LinkedList가 더 빠름
- 근데 10만개 등 이상으로 되면 ArrayList가 훨씬 빠름(단순 저장, 처리 빠름)
- LinkedList '중간 삽입' 또는 '중간 삭제' 빠름

특이사항
- 순서는 있는데 인덱스는 없음
- 순번에 의해서 결정된 순서가 아니라 앞뒤의 주소를 참조된 순서이기 때문입니다.
- 컬렉션 리스트에서 LinkedList는 주소에 의해서 묶여있는 것이지 순서에 의해서 묶여있는 것이 아닙니다.
- LinkedList는 index 대신 node가 있는 것입니다. (배열을 사용하지 않고 node라는 객체를 이용하여 체인 형식으로 앞뒤를 연결하여 데이터를 저장함)


-----2교시-----


(간단히 말만)
(Set 사용하는 경우가 거의 없음)
Set
- 인덱스가 없기 때문에 '중간 삽입' 또는 '중간 삭제'가 불가능함
- 그냥 값으로만 삭제해야됨
- 1을 100번 넣어도 1이 하나만 삽입되어있음
- 중복을 허용하지 않기 때문입니다.
- 첫 번째 포함된 데이터 이외의 중복 데이터는 무시합니다.

- 순서가 없기 때문에
- 값이 ~


-----

배열을 리스트로
리스트를 배열로 가능
- 이클립스에 구현


---리스트---
제네릭을 이용해서 어떤 데이터를 넣을지 선언
jdk1.7

삽입은 add
중간삽입은 index add
등등 eclipse 참고

↑ 리스트의 기본적인 사용 방법



-----3교시-----


Map은 Spring에서 많이 사용됨
Map과 비슷한 방식으로 데이터 저장 방식이 비슷한 애들이 많음

Map 데이터 저장 형태
<Key, Value>
key 및 value에 대한 데이터 둘 다 제네릭에 넣어야 됨
그래서 Hashtable로 데이터를 저장하게 됨

Hash 값이란
- 객체 형태의 애들은 주소가 있음
- Java에서 제공한 주소는 hashcode임
- hashcode는 16진수입니다.

객체는 두 가지로 비교할 수 있습니다.
1. 주소
2. 값
같은 객체인지 아닌지는 주소와 값으로 비교합니다.
주소는 hashcode입니다.

--hash 충돌 현상--

Apple a = new Apple();
Apple b = new Apple();
a와 b의 apple의 주소는 달라야 됨
a.set(5);
b.set(6);

그런데 아주 가끔 hash 주소값이 같아져 버리는 경우가 있습니다.
그래서 값도 비교해야 됩니다.
만약 값도 같으면 두 객체를 동일하다고 판단합니다.(이런 경우는 거의 없음)

--hash 충돌 현상--


--Map의 종류--

1. HashMap(가장 많이 사용됨)
- 순서가 없습니다.(Map에서 순서를 필요로 하는 경우는 거의 없습니다.)
- key value가 쌍으로 이루어진 데이터 형태입니다.
- key는 중복이 불가능하기 때문에
- key만 알면 데이터를 찾을 수 있기 때문에 순서는 중요하지 않습니다.
- 그리고 hash (주소(?))값으로 데이터가 저장됩니다.

key 중복 시
apple, 5
apple, 4
apple, 6
나중에 들어온 데이터의 value 값으로 key 데이터를 치환해버립니다.
5에서 4로, 4에서 6으로 치환합니다.
최종적으로 apple의 key가 6으로 설정됩니다.
value update

중간 삽입, 삭제 x
Map은 데이터를 쌍으로 집어넣기 때문에 수정하는 속도가 List보다 훨씬 느림
그럼 언제 빠를까?
데이터를 찾을 때는 겁나 빠름

2. LinkedHashMap
- 앞뒤 관계가 있고 순서가 있는 HashMap
- 하지만 인덱스는 없습니다.

3. TreeMap
- 거의 사용하지 않음(잊어버려도 됨)



★★★★★ 강의 마지막 부분(22:18)

강의 정리
자료구조의 집합
리스트 겟 셋?

list

set은 리스트와 비슷하나 순서가 없음 (중간 삽입 중간 삭제가 없음)
그리고 set은 중복을 허용하지 않기 때문에 처음 들어온 데이터를 제외하고 나머지는 무시함
그래서 중복 삭제를 위해서 사용하게 됨
사용자 입장에서는 잘 사용하지 않게 됨

map은 key와 value로 이루어져 있음
검색에 있어서는 빠름
key의 중복을 허용하지 않음
put을 넣었을 때 putIfAbsent?

iterator 내부 커서
Map에는 없고 List와 Set만 갖고 있음



-----다음 시간-----
리스트 가지고 예제를 만들어 볼 것임
String
예외처리
part2로 넘어가고 Java 수업도 마침

월요일
HTML
CSS

📌 11. 2024-05-09 수업
- 20240509-데이터베이스 수업(정리완료)

데이터베이스
MariaDB

초기에는 파일 시스템을 사용했었음
파일 용량에 제한이 있음
프로그램 용량이 커지다보니 파일이 25만개가 있어버림

디스크 모드보다 디지털 모드가 더 빠름

* IBM 직원 아저씨
- 공장 시스템 만들러 갔는데 기존의 파일 시스템으로 만들면 퍼포먼스가 안나올듯
- database management system

수스


MariaDB
가볍고 작고 빠른 성능
설치 쉽고 사용 쉽고


라이센스들의 기능
MySQL MariaDB 2~3 등



---MariaDB 설치 완료---

논리적인 방 설정
a 방 b 방 c 방
애플리케이션을 하나 당 하나 데이터베이스 구매하려면 너무 비쌈

만들때는 database 명령어
말할때는 schema



---DBeaver 설치 완료---

데이터베이스 주석은 
한 줄, 여러 줄이 있는데
무조건 여러 줄로 해야됨


-- 주석

/* 직렬화 */

*** 다중 주석의 중요성
DBMS에서 한 줄로 주석처리를 해버려서 에러가 발생될 때가 있음
데이터베이스가 java처럼 ~~ 주석이 가려짐
파일 처리로 데이터베이스를 입력할 때 한 줄 처리로 주석 때문에 에러가 발생될 수 있음
파일을 통으로 처리하면 문제가 발생됨

📌 12. 2024-05-13 강의
- 20240513-(정리완료)자바 수업

---1교시---

예외처리 : 프로그램이 죽지 않게 만드는 것
프로그램을 죽이는 것이 나을지 살리는 것이 나을지
예외처리 : 프로그램이 동작하는 중에 일부 문제가 있을 경우 해당 문제를 처리하여 프로그램 구동에 문제가 없게 하는 것
언제쓸까 가 어려움

예외처리가 FIX는 아님

예외는 2가지가 있음
일부러 발생시킨 예외
예측한 예외
예측하지 못한 예외

코드
에러

* JVM
- NoClass : 클래스 못찾음
- classNotFound
- nullPointer
- ArrayOuterFound 등

에러가 발생한 지점으로 돌려줌
에러를 처리하면 예외처리
내버려두면 에러로 인한 시스템 지정상 종료


런타임 에러
Scanner를 닫지 않으면 메모리가 닳게 되면서 에러
사용자가 무조건 숫자를 입력할 것이라고 예상했는데 갑자기 문자를 입력했을 때
문법적으로는 문제 없는데 실행했을 때 에러가 발생되는 경우(15 나누기 0 = 정수 나누기 정수)


Error의 종류 나열
메모리 부족
디스크 공간 부족
CPU 부족

문법 Error
실행 안됨

Runtiem Error
Checked Exception : IO 관련(데이터베이스 등) / 시스템 상에서 발생될 수 있는 예외
Unchecked Exception : 개발자 실수
exception = try catch
주니어는 예외처리 사용해도 되는데 시니어일수록 예외처리 사용 x(개발을 더 잘해야됨)
시니어일수록 예외처리보다 코드방어(try catch)가 더 높아야 됨

메서드를 호출한 쪽에서 예외 처리를 try catch = throw exception


예외 던지기의 목적
1. ~~ 전가
- 보통 checkedException을 던짐

2.~

checked보다는 unckecked 사용



요약 : 예외처리와 예외처리 던지기 설명
---1교시---

---2교시---
임의의 예외처리
Scanner

받아주는 곳이 있어야 임의의 예외처리가 가능함

참고로 회사는 예외처리 양식을 다 짜뒀기 때문에 주니어 개발자가 만들일은 없음



---자바 강의 끝---


인재 위험
update
delete
+ alter

신입
select
insert는 괜찮

데이터베이스는 컬럼의 순서를 기억하지 않음

select
from
order by
where

복습 필요

📌 13. 2024-05-20 강의
- 20240520-html수업(정리완료)

---1교시---
html css 역사

react는 무엇인지
javascript는 무엇인지
node는 무엇인지
view는 무엇인지 등

bootstrap
페이스북
css 프레임워크
단어만 입력하면
전 세계 75%이상 사용
현재 버전 5
---1교시---

---2교시---
카멜방식 가능
원래는 언더바

---html 실습 시작---

html 코드의 작성 규칙
기술적인 의미는 없지만 기능적인 의미는 있음
html의 모든 컨텐츠는 body, 설정값은 head, 짜바리 footer

빈 공간에 html 작성하고 html 5 클릭
기본 형식이 만들어짐

html
- 문서 타입을 html로 설정

head(머리)
- 정의가 들어감
- meta : 문서의 데이터(문서에서 문서를 설정하는 메타 데이터)
- charset : 어떤 인코딩
- 반응형 웹을 위해서라면 viewport가 반드시 삽입되어야 됨
- scale은 해상도에 따라 웹의 너비가 움직여지지 않음
- initial-scale=1.0 : 어떠한 배율의 화면에서 보더라도 원본을 유지하겠다는 의미

title
- 탭에 표시되는 글자

body(가슴)
- 화면 내 내용
- 브라우저 화면에서 보여지는 내용을 작성하는 곳

foot(배)
- 사이트맵 아니면 요새는 잘 안씀
---2교시---

---3교시---
title.html

---실습 끝---

태그는 두 가지 형태로 나뉨

1. 싱글태그
중간에 내용이 있어야 되는 태그는 열리고 닫힘
그런데 싱글 태그는 중간에 내용이 필요없이 그냥 사용됨

<br>
<input value=""> 등


2. pair 태그
<ul></ul>
<ol></ol>


3. block tag
- 태그 1개가 1줄을 다 차지함
- 하나의 블럭을 태그 하나가 다 차지한다
- 실습 내용에서 아이유 하나, BTS 하나 등
- 자기 자신이 하나의 
<li>하나가 한 줄이면 블럭

4. inline tag
- 자기 내용까지만 영역
- <span>

---

개발자 도구 F12가 FireFox가 잘 되어 있음
왼쪽 위 화살표를 클릭하면 원하는 곳 선택 가능(Ctrl + Shift + C)

📌 14. 2024-05-21 강의
- 20240521-html,css,js 수업(정리완료)

---1교시---

* semantic 태그의 반대

* div 태그

* html4
- div 말고 table로 ~를 만들었음
- 왜 div로 만들었냐면 table이 표준어가 아니었기 때문임
- 표준어가 아니면 html 업그레이드 시 사라질 것 같아서 개발자들이 사용하지 않았었음

* Element
- <></> 태그의 시작과 끝(1 tag)

* Element에 속성을 부여하는 것
id : 중복되면 안되는 것
name : 그룹화할 때 중복시키긴 함
style : css가 들어가는 항목 / inline 방식 / 그런데 inline 방식으로 style 사용하지 않는 것을 추천
readonly : 읽기전용 : 화면에 데이터는 보이지만 고칠 수 없는 것
placeholder : id를 입력하세요, password를 입력하세요 글자 있다가 없어지는 안내 멘트
value : 값 넣는 곳,
type : element가 어떤 유형 또는 속성을 가지냐(div면 div 속성)
class : 공통적인 css를 제공해주는 이름을 만들 때?

* element에 이름(?)을 붙이는 세 가지
1. id : 번호
2. name : 이름
3. class : 스타일을 부여할 때 사용 / id가 다르고 이름도 다른데 같은 색상(예를들면 pink)을 입히고 싶을 때 등(패드 내용 캡처)

* css (cascading style sheet)
1. 원하는 스타일을 element tag 자체에 부여 가능
2. 원하는 스타일을 element name에 부여 가능
3. 원하는 스타일을 element id에  부여 가능
4. 원하는 스타일을 element class에 부여 가능

광고업체 서버 점검 기간(25일부터 열흘 정도, 트래픽이 엄청남) / 서버 한 번 내렸다 올리면 30분 정도 걸리는데 서버에서 뭔가가 잘못돼서
---1교시---



---2교시---
---area01 실습 시작---
div는 내용은 없고 코드만 있으면 존재가 없는 것으로 처리됨



---3교시---
3교시부터 수업 다시 듣기(부장님 전화)

form으로 감싸진 데이터만 전송 가능함


input 태그를 많이 사용하게 될 것임

---21:40까지 듣기---

프론트엔트 이력서를 html, css, js로 제작
누르면 이벤트로 책장이 넘어감, 소리도 들리고
제작하는 데 4달 걸렸다고 대답함

포트폴리오는 하나만 제대로
(소스코드 세장만 봄)
(프론트는 메인페이지 한 장)

아키텍처가 어떻게 구성되어 있는지
프론트는 어떻게, 백은 어떻게

---21:53---
기술블로그 장점
- 실력 많이 쌓임
- 포트폴리오 대용

---21:56---
table 설명 시작

* table
<thead></thead>
<tbody></tbody>
<tfooter></tfooter>

table이 표준어로 채택되면서 기본적인 스타일이 없어짐
그래서 head 태그 내부에 style을 정의해야 됨

---22:10--- (2024-05-22로 넘김)
js 실습 시작
- js 언어는 1주일만에 개발됨

* javascript 만든 이유
- 원래는 livescript
- html에 dynamic함을 주기 위해 개발됨
- 함수 기반으로 개발된 언어(python과 구조가 비슷함)
- js는 브라우저가 해석함
- html은 브라우저가 해석함
- html 해독기와 js 해독기는 따로 있음
- 그래서 html 해독기로 먼저 렌더링 되고 이후 js 해독기로 렌더링(?) 됨

* 연산자
- 연산자는 java와 같기 때문에 안배워도 됨
- java는 int a + byte b 등 데이터 타입이 여러가지가 됨
- js는 아무거나 막 집어넣으면 됨
(js의 연산자는 응용 학습 해보기)

📌 15. 2024-05-22 강의
- 20240522-html,css,js 수업(정리완료)

js 실습 시작
- js 언어는 1주일만에 개발됨

* javascript 만든 이유
- 원래는 livescript
- html에 dynamic함을 주기 위해 개발됨
- 함수 기반으로 개발된 언어(python과 구조가 비슷함)
- js는 브라우저가 해석함
- html은 브라우저가 해석함
- html 해독기와 js 해독기는 따로 있음
- 그래서 html 해독기로 먼저 렌더링 되고 이후 js 해독기로 렌더링(?) 됨

* 연산자
- 연산자는 java와 같기 때문에 안배워도 됨
- java는 int a + byte b 등 데이터 타입이 여러가지가 됨
- js는 아무거나 막 집어넣으면 됨
(js의 연산자는 응용 학습 해보기)


---실습---
form01.html

* 2024-05-22 강의

---1교시---
react16 등등 component 방식으로 함수형으로?
timescript? angular? dart?

* 백엔드
1. 열심히만 학습하면 개발이 됨
2. 업무의 변동성이 적음
3. 길이 하나임(로직, 알고리즘)

---19:56---

포지션 관련 내용


---2교시

css를 잘 하려면
1. 미적 감각
2. 공간 감각

1. flex
- 상대적으로 쉬움(절대적으로는 어려움)
- 기존 기능

2. grid
- table처럼 구분하여 사용
- 어려움
- 근데 최신 기능



--- 3교시 ---

flex
- 가로 배치
- 세로 배치

22:04

javascript의
- for문
- 배열

js는 collection이 없음
- list처럼 추가 삭제 가능(배열이 애초에)
- map이 없음 = map같이 생긴 것이 많음
- set은 있음
- js는 바로 실행됨(영역 자체가 실행코드 영역)
- print가 2개임

📌 16. 2024-05-23 강의
- 20240523-(정리완료)익명함수, 콜백함수

---1교시(functionExam01)---
함수형 클래스
- 하나의 기능을 가진 클래스
- Java는 태생적으로 함수형 프로그램이 안됨?
- 함수가 주인공인
- 기본적인 인터페이스 = 메서드 여러 개
- 함수형 인터페이스 = 메서드 단 한 개(주인공이 함수)

익명 클래스
- 1회용 클래스
- 객체를 선언할 때 메모리에 올라감
- 익명 클래스는 객체를 선언할 당시에는 메모리가 올라가지 않음
- 익명 클래스를 실제로 사용할 때 메모리에 올라감

* 껍데기를 인터페이스로 만든 이유
- 클래스로 정의하면 주인공이 함수가 아니게 됨
- 주인공을 함수로 만들 수 있는 인터페이스

* 익명 함수를 만드는 이유
- 안드로이드 버튼 이벤트 만듦
- 근데 버튼이 100개이면 객체로 선언하면 메모리에 버튼만 100개가 생김
- 근데 실제 사용되는 버튼은 40개 밖에 없음 = 60개가 낭비중
- 버튼의 동작은 클릭 하나밖에 없음
- 저장할 때의 동작, 수정할 때의 동작, 삭제할 때의 동작(클릭)
- 클릭했을 때 발생되는 로직만 다름
- 버튼마다 클릭 메서드 안에 잇는 내용만 바꿔줘도 됨
- 그래서 함수형 인터페이스를 사용함
- 인터페이스 만들어놓고 필요할 때 클릭하면 메모리에 올라감
- @FunctionalInterface 선언하면 메서드 2개 만들었을 때 에러 발생됨(invalid ~ funtion interface는 메서드가 하나만 있어야 된다는 오류)

- 익명 함수? 익명 클래스? 함수형 인터페이스? 뭐가 맞는 말?

- 자바에서는 람다
- 자바스크립트에서는 화살표 함수

한 줄로 표현 가능
Calculator calc3 = (int x, int y) -> x + y;


---정리---

* Java에서 함수형 인터페이스란
- 함수가 주인공임
- Java는 클래스 또는 인터페이스를 벗어날 수 없어서 완전한 함수 기반 프로그래밍은 불가능함
- 그래서 함수형 인터페이스를 생성해야 됨
- 함수형 인터페이스는 하나의 메서드만 갖는 것임
- 한 개만 가질 때는 자동으로 판별됨
- 함수형 인터페이스를 예쁘게 꾸미기 위한 람다식
- 람다를 사용하면 식이 간편해짐
- 함수형 인터페이스의 선언을 익명클래스 선언이라고 함
- 이유는 클래스 선언 시 메모리(heap)에 올라가는 것이 아니라
- 메서드를 실행 할 시에만 잠시 메모리에 올라갔다 내려감

---1교시---

---2교시(functionExam02, 03)---

* 콜백 함수(함수에서 제일 어려운 것)
- 어려운 js 함수
- 콜한 것에 응답을 받는 것
- 나중에 비동기 프로그램 할 때
- 기본적인 함수를 정의해놓고 루프 등을 사용해서 콜백 함수를 통해 함수들 재활용 가능?
- 기본적인 정의 : 어떤 함수의 실행 결과로써 실행된 결과를 보여주기 위해서 사용되는 또 다른 함수
- 잘 사용되는 곳 : 비동기 처리 결과를 보기 위한 곳

* 동기
- 한 타임에 하나밖에 못함
- 1초 때 뭐만 됨
- 2초 때 뭐만 됨
- 등 타임라인대로 이루어지는 것

* 비동기
- 나는 뭐 할 때 동안 너는 뭐 해
- 뛰는게 끝난다음에 어딜 가는 순서가 지켜지지 않고 동시에 일어날 수 있게 됨
- 너가 도착하면 벨을 눌러
- 어떤 함수가 실행되는데 그 함수가 종료되는 시점은 모르는데, 그 함수가 종료될 때 실행되는 함수가 콜백 함수

* 비동기 함수 정리
- 콜백 함수라는 것이 있다.
- 그것은 비동기 통신을 하는 것이다.
- 그것은 어느 함수의 일이 끝났을 때 일이 진행되는 것이다.

* 동기와 비동기
- 이미지 참고

* 함수 시작/종료 실습
* javascript loop 함수 실습

---2교시---

---3교시(event.html, keyEvent.html)---

인터프리터 언어: python(대소문자 구분 안함), js(그럼에도 대소문자 구분 함)


언제 onclick? 언제 script?
button도 html이 아니라 js로 그릴 때
그때 버튼 그림을 js로 줌
script로 할 때는 event 객체를 받아줌
그런데 html에서 event 를 앞으로 안하겠다고 빼버림
아이디/패스워드 때 엔터만 눌러도 로그인되는 것 = 엔터 처리할 때 어쩔 수 없이 javascript로 기능 부여 해야 됨

(다음주)
css 위주, bootstrap


keyEvent.html
- 엔터이면 sendBtn 실행될 수 있게 설정

📌 17. 2024-05-27 강의
- 20240527-(정리완료)html, jQuery, 버튼, 로그인 페이지 제작 수업

--- 1교시 ---

* 리액트
- 클라이언트 사이드 어려움
- 서버 사이드 어려움

* 뷰
- 서버 사이드 쉬움

* 리액트
리액트보다 javascript 학습이 더 중요함
원천이 js라서
디자인은 css

key 이벤트
로그인 생성하려고

---

* jQuery
- react나 view를 사용하지 않고 j query 사용하여 웹 페이지 만드는 회사 꽤 있음
- 기존에 j query로 제작된 사이트 유지 보수
- 대체 기술이 나왔기 때문에 인기가 없어졌지 쓸 데 없는 것은 아님
- jQuery는 js이고 js는 jQuery가 아님
- jQuery는 하나의 js 플러그인임
- jQuery는 자체로 객체임
- jQuery는 자체가 클래스임(<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>)
- $ = jQuery (둘 다 클래스; jQuery 객체 지시자; 접근할 때 . 사용)
- 함수를 이용하여 사용
- Car car = new Car(); 처럼 $. jQuery. 으로 접근하여 사용
- JavaScript 객체 → jQuery 객체
- input = document getElementById

* jQuery 다운로드
- https://jquery.com/download/
- linkjQuery CDN 목록에서 jsDelivr CDN 클릭
- js 코드 복사해서 Copy HTML
- body 아래에 붙여넣기
- <script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>

* 선택자
- tag 자체
- #id
- .class
- name

* jQuery 사용 방법
script의 객체를 jQuery obj로 변환하여 사용

* jQuery 객체로 만드는 방법
- $ 다음 괄호 안에 있는 것이 jQuery 객체
- "$()" = "new jQuery(parameter)" 관계라고 연상하면 됨

1. $("#id")
2. $(#.class")
3. $(isObject)
4. $("inputCa~)

* jQuery 선택자

--- 1교시 ---


--- 2교시 --- jqueryExam02, 03.html

jQuery 선택자와 java 생성자의 다른 점

* css에서 공간 관련
1. margin
2. padding
- top, left, bottom, right

* margin
- 공간 vs 공간의 간격
- div 끼리의 간격
- a b c d; 가능(padding 마찬가지)
- 10px 10px 10px 10px;
- 시계방향으로 top right bottom left 순서
- 4개: top right bottom left 순서 */
- 2개: top + bottom, right + left 순서*/
- 3개: top, right + left, bottom */
- 1개: 전 방향 */
- 한 방향만 하고 싶으면 maring-top, margin-left 등 부여

* padding
- 공간 안에서의 간격
- 내부 공간 여백

* 바닐라 스크립트
- JavaScript에서 jQuery 형태를 제외한 순수 js 코드로만 작성하자는 운동(별 것 아님)

--- 2교시 ---


--- 3교시 ---
-loginForm.html 실습

로그인 페이지 제작 실습

이벤트 처리는 내일

📌 18. 2024-05-28 강의
- 20240528-(정리완료)Bootstrap 실습

--- 1교시 ---
- 2024-05-27의 loginForm.html 이어서 실습


* 호일스팅
- 나중에 정의된 함수를 이전에 정의된 함수가 불러들임

// 익명 함수 (맞는 내용인가? 변수에 함수를 저장시킨 함수)
// 익명 함수는 함수가 읽힌 다음에 사용됨(?)
// 익명 함수는 함수라고 해도 변수에 저장된 함수(함수가 실제로 메모리에 등재되지 않고 변수만 등재됨)
// 익명 함수는 버튼 이벤트 만들 때 많이 사용되는데, 메모리에 기억될 필요 없고 이벤트만 발생되면 되는 함수를 익명 함수로 처리함
// 익명 함수의 주인공은 함수가 맞음

- 로그인 페이지에 익명 함수 사용하여 기능 부여(js)

---1교시---

---2교시---
- bootstrapExam01, 02.html

* bootstrap
- 이미 정형화 된 css를 가져다가 사용할 수 있는 하나의 디자인 템플릿
- 로그인 페이지를 제작하기 위해 공을 들였지만 사실 더 편리한 방법이 있었음
- 자체는 무료인데 bootstrap 대쉬보드, 컴포넌트는 판매중임

* bootstrap 다운로드 방법
- bootstrap의 4.6버전 다운로드(4.6 버전이 jQuery 호환 가능)
- https://getbootstrap.com/docs/4.6/getting-started/introduction/
- CSS 코드 카피
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" integrity="sha384-xOolHFLEh07PJGoPkLv1IbcEPTNtaed2xpHsD9ESMhqIYd0nLMwNLD69Npy4HI+N" crossorigin="anonymous">

- body 태그 아래에 카피
<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js" integrity="sha384-+sLIOodYLS7CIrQpBjl+C7nPvqq+FbNUBDunl/OZv93DB7Ln/533i8e/mZXLi/P+" crossorigin="anonymous"></script>

- 레이아웃 확인
https://getbootstrap.com/docs/4.6/layout/overview/

반응형은 responsive

- 플루이드 실습
<!-- fluid = 가로 영역을 전부 사용하는 반응형 사이즈 -->

- 컴포넌트에 다양한 양식 많음
https://getbootstrap.com/docs/4.6/components/alerts/

- form에 양식이 훨씬 많음
https://getbootstrap.com/docs/4.6/components/forms/

- input group : 커스텀 된 애들
https://getbootstrap.com/docs/4.6/components/input-group/


---2교시(수업 자체 종료)---




회원 페이지는 다음 시간에

📌 19. 2024-06-11 강의
- 20240611-(정리완료)Spring 프로젝트 생성을 위한 세팅(수업 내내)

--- 1교시 ---

* Java EE 버전 (Enterprise Edition)
- 웹 프로젝트 개발이 가능한 버전

* 웹 프로젝트 개발 요령
- 프로젝트명에 대문자를 입력하면 안됨(정확히는 대소문자 입력을 조심해야 됨)
- 옛날(15년 전 등)에는 웹 프로젝트는 서버에 올라가면 이름으로 경로가 생성됨
- 그런데 요즘에는 프로젝트의 이름으로 경로가 생성되지는 않음
- 소문자로 찍힘
- 컴퓨터는 원래 문자를 모름
- 컴파일 과정에서 대소문자를 잘못 작성하고 컴파일 시키면 문제가 발생됨
- 캐시를 지우는 것만으로는 부족함?
- 대소문자를 틀리고 한 번 컴파일되면 대소문자를 고친 것을 컴퓨터는 인식하지 못함
- 한마디로 있던 것처럼 내두면 안됨
- 방법은 로그를 싹 다 날리고 처음부터 다시 세팅해야 됨
- 그래서 이를 통일하기 위해 프로젝트명에 대문자 입력, 띄어쓰기, 언더바 등 특수기호 입력을 지양함
- 경로에는 소문자만 입력, 특수기호 입력하면 하이픈을 입력함
- 포트폴리오 명에 대문자를 넣으면 안됨(sample07, html07 등으로 입력하면 됨)

* Spring 개발 환경 준비 사이트
https://spring.io/tools

* JSP 소개 (Java Server Page)
- Java + HTML + CSS + JS 언어가 혼합된 것이 JSP입니다.
- Java 단 : Server Side
- HTML 단 : Client Side
- server 단은 client 단에 간섭할 수 있음(서버 내용을 html에 전달 가능)
- client 단은 server 단에 간섭할 수 없음
- JSP에서 프론트엔드 화면만 구성할 목적이라면 Java가 없어도 됩니다.

* JSP 3단 구성
- basic 구성 : 화면/처리/결과
- view.jsp : 화면(client?)
- service.jsp : 화면에 대한 처리 / Java 코드? / 로그인 요청을 처리해주는 페이지
- result.jsp (half & half) : 로그인 페이지의 성공/실패 결과(그래서 result가 view 일 수 있음)
- JSP 스스로가 웹 페이지이자 서버 페이지

* JSP vs Servlet
- Servlet의 경우 view 페이지만 구성했을지라도 Java 코드가 필요했었음
- Servlet은 Java 코드 안에 디자인을 넣은 형태임
- JSP는 디자인 안에 Java 코드 넣은 형태임
- 불필요한 Java 코드가 많았기 때문에 Servlet 대신 JSP가 더 사용됨
- 예를들면 Java에서 뷰포트를 구성하려면 print가 수없이 필요함(HTML은 태그 정도 필요)
- 그래서 JSP를 사용했을 때 코드 작성/유지/보수가 보다 편리하고 디자이너와의 협업도 더 편함


--- 2024-06-19 22:53 정리 내용 ---
--- 2024-06-19 22:53 정리 내용 ---
--- 2024-06-19 22:53 정리 내용 ---




* .jar
- 실행 압축 파일
- 압축하여 보관하는 것이 아니라 Java 코드로 실행 가능

* Spring 사용 메모리 튜닝 방법
- 다운로드 받은 sts 폴더에서 SpringToolSuite4.ini 클릭
- 하단부에 256m로 설정되어 있는 Xms 값을 Xmx(최댓값) 값과 동일하게 2048m으로 변경

* 이클립스 세팅
- Java EE 화면 구성으로 변환
- 웹 개발에 편리한 화면
- Java EE에서 html 등 코딩 가능
- 최신 이클립스에서는 Open JDK가 기본 사용되지만 강의에서는 사용하지 않음
- 왜냐하면 우리는 학습하는 사람이니까

* UTF-8 설정
- Windows 탭 → Preferences → General → Content Types → Text → Spring Properties File → Default encoding 입력창 → ISO-8859-1 내용을 UTF-8로 수정 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → JSP → ISO-8859-1 내용을 UTF-8로 수정 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → JSP → JSP Fragment → ISO-8859-1 내용을 UTF-8로 수정 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → JSP → JSP Tag Definition → ISO-8859-1 내용을 UTF-8로 수정 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → CSS → 공란에 UTF-8 입력 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → HTML → 공란에 UTF-8 입력 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → Java Source File → 공란에 UTF-8 입력 → Update → Apply and Close
- Windows 탭 → Preferences → General → Content Types → Text → Java Properties File → ISO-8859-1 내용을 UTF-8로 수정 → Update → Apply and Close

* JDK 경로 설정
- Windows 탭 → Preferences → Java → Installed JREs → Edit → C드라이브 등에 위치된 JDK 17 선택 → 'jre'를 'jdk-17'로 수정 → Finish

* Tomcat
- 하나 당 1,000명  정도 사용자는 감당 가능합니다.
- 그래서 초반 서버는 Tomcat을 사용하면 좋습니다.
- Tomcat은 무료입니다.

* 웹 서버 개념
- 웹은 웹 서버와 웹 컨테이너로 구분됩니다.
- 예를들면 Tomcat은 웹 컨테이너고 Apache는 웹 서버입니다.
- 그런데 Tomcat은 웹 서버도 어느정도 커버는 가능합니다.
- Apache 안에 Tomcat이 들어있었는데 성능이 부족해서 Tomcat만 사용합니다.
- Apache는 서버 이전 시 ip 할당, 서버 연결 등의 기능이 요구될 때 사용합니다.

* Target runtime
- Tomcat 다운로드 필요
- https://tomcat.apache.org 접속 → Tomcat 9 → Core → zip 클릭(다운로드)(윈도우 급은 필요 없음)

* Tomcat 구조
- bin, conf, lib 등 뜻 파악 필요(GPT 검색)

* Tomcat 서버 포트 변경
- 8080 서버를 사용하는 앱들이 많음(ZOOM 등)
- 그래서 서버 포트 변경이 필요함
- apache-tomcat-9.0.89 → conf → server.xml → '메모장에서 편집' 클릭
- 8005 서버 포트 : 서버 종료 시 사용
- 밑으로 쭉
- 주석 처리가 되어 있지 않은 'Connector port="8080" protocol="HTTP/1.1"'를 포함한 곳의 포트 번호를 9090으로 변경함
- 'maxParameterCount="1000"' 뒤에 'URIEncoding="UTF-8"' 입력
- 'maxParameterCount="1000" URIEncoding="UTF-8"' 입력 완료 모습
- VSCode에서 xml 파일 열면 구분이 쉬움


----- 2024-06-21 정리 완료 -----
----- 2024-06-21 정리 완료 -----
----- 2024-06-21 정리 완료 -----


* Spring 서버 설정
- Windows 탭 → Preferences → Server → Runtime Environment → Add → Apache → Apache Tomcat v9.0 → Next → Browse → Tomcat 경로 선택 → JRE → jdk-17 → Finish → Apply and Close
- Eclipse는 원본에 링크를 걸면 원본을 복사함
- 따라서 가상의 Tomcat을 새로 만듦
- 프로젝트 Targeted runtime에 Tomcat 확인

* 웹 프로젝트 생성 방법
- Create a Dynamic Web project 클릭 
- 프로젝트명 입력(웬만하면 소문자만, 숫자도 안됨)
- Next → Next
- webapp을 ~ 구분을 위해 webcontent로 수정
- src/main/webcontent
- (체크) web.xml은 항상 생성
- webcontent 우클릭 → New → JSP File
- 만일 EUC-KR이면 UTF-8로 수정
- 내용 입력후 Tomcat 서버 start
- 브라우저 주소창에 URL 입력(http://localhost:9090/web-app1/hello.jsp)(확실히 접근 가능하니까 URL?)

* 웹 프로젝트 구조
- java 폴더에는 java 코드
- 웹 관련된 것 : webapp, webcontent 등
- META-INF
- WEB-INF : 라이브러리, 직접적인 접근(URI? URL?)이 불가능함, URL로는 접근 불가능함, jsp가 들어갈 곳

* 기타 개념
URL : 직접 리소스 접근
URI : 무언가를 얻을 수 있는 포인트만

* 가상 서버 생성(설정)
- Console 옆의 Server 탭 클릭
- Apache → Tomcat v9.0 Server → Servaer name을 web-app1 server로 수정(기존 : Tomcat v9.0 Server at localhost) → Next → Add all → Finish
- 서버 더블 클릭
- Overview 탭 옆에 있는 Modules 탭 클릭 → Auto Reload는 Enabled 상태여야 됨

--- 수업 종료 ---

📌 20. 2024-06-17 강의
- 20240617-(정리완료)jstl, cookie, session 수업

hello.jsp
form.jsp
result.jsp
까지 해봄(호출까지)

--- 1교시 시작 ---
ㅁ 결론

* Servlet
- Java 안에 html 태그

* EL
- ${}

* JSTL
- Java Server Tag Library


*** 실습(호출까지 해보기)
---

Servlet
EL


* Java Build Path
- 내부 라이브러리를 프로젝트에 적용할 때
- 예를들면 jstl.jar, standard.jar

* Deployment Assembly
- 외부 라이브러리를 프로젝트에 적용할 때

* 내장 객체
request
response
out = print writer = 객체를 생성하지 않고도 사용할 수 있는 내장 객체

* param
- request getParameter에서 뽑은 애

* EL
- Expresstion Language
- 달러 표시 + 중괄호
- ${}
- jstl이랑 같이 사용하는 애

* jstl
java standard tag library
- if문 같은 것

* prefix="c"
- jstl 문법이라는 것을 인식하기 위해서 prefix를 붙임
- tag lib는 jstl 뿐만 아니라 Spring tag, message tag 등 다양함

* Spring Boot
- jstl 필요 없음
- 비슷한 구조를 가진 다른 것을 배움(thymeleaf)
- 단지 jstl이라는 것이 서버 사이드에서 넘어오는 코드를 처리하는 것이라고 배운 것 뿐임

--- 1교시 종료 ---

--- 2교시, 3교시 시작 ---
ㅁ 결론
* Cookie
- cookie는 클라이언트 사이드에 정보가 저장되는 객체(중요한 정보 담으면 안됨)
* Session
- session은 서버 사이드에 정보가 저장되는 객체(중요한 정보 담을 수 있음)
* Cookie vs Session
* JWT
* 토큰키
* 스토리지
- Local Storage : 브라우저 전체(탭하고 상관없는 전역 변수와 같은 느낌)
- Session Storage : 탭 한정(다른 탭으로 넘어가면 정보를 모르는 지역 변수와 같은 느낌)
- 시간 설정이 없기 때문에 브라우저 상에 지속적으로 남겨야 되는 정보라면 local storage 사용(장바구니 기능, 오늘 본 top 7 등의 서버 사이드)
- html5부터 쿠키와 세션을 대체할 수도 있는 storage가 있음
---

* 웹 특징
- 기본적으로 동적이 아닌 정적 페이지
- Web Page = State less
- 그래서 쿠키 등을 이용하여 상태를 저장하게 됨

* 쿠키
- 클라이언트가 서버에 대한 내용을 저장한 것
- 사용자(클라이언트)가 갖고 있는 것임
- public 객체이기 때문에 모두가 볼 수 있음
- 접속했던 기록이 cookie에 남음

* 세션
- 연결고리
- 예를들면 네이버 사이트에 동시 접속했을 때 사용자를 구분할 수 있어야 됨
- ip로 구분한다고 해도 한 ip에서 접속했다고 했을 때 어떻게 구분될까?
- 이를 구분하는 것이 세션
- 세션을 받지 않겠다고 말하는 것이 아닌 이상 세션이 생성됨

* 세션 로그인 방식
- 세션에는 중요 데이터가 포함되기 떄문에 로그인 정보가 담김
- 언제 어디에서 로그인했는지 등
- 그럼 쿠키는 왜 필요할까?
- 브라우저를 닫으면 임시적으로 세션도 닫힘 : 예를들어 브라우저를 잠시 껐다 켜면 그대로 로그인 되어 있음
- 장단점
- 서버 클라이언트 수가 많아지면 서버 유지가 힘들어짐
- 그래서 JWT가 탄생함
- 세션은 30분 정도 유지

* JWT
- 키를 만드는 방식등이 동일함?
- 토큰의 유효시간 내에 접속을 해야 되는데 안하면 접속 못함
- JMT는 언제 정도 유지
- 유효시간 이내에 서버에 접속하면 키를 재발행
- 왜냐하면 누군가 GET 했을 때 재활용될 위험이 있기 때문임
- JWT가 있을 떄와 없을 때
- 정보 보고 유효시간 안되면 튕겨냄?

* 토큰키
- 잠시

--- 내용 정리 ---

* 세션(Session)
- 클라이언트와 서버의 관계를 식별해내기 위한 '객체'
- 세션이 끊어지는 것 1 : 유효시간 내에 서버엣 재접속하면 다시 30분 정도 걸림; 그런데 유효기간이 지나면 서버가 session을 지움
- request에 있음 : 세션이 생기는 때는 사이트에 접속했을 때
- 웹 사이트에 접속했을 때 : 웹 페이지의 기사, 페이지 등을 볼 수 있다는 뜻은 서버에 다녀왔다는 뜻
- 웹 사이트를 나갔을 때 : 그럼에도 세션이 유지됨(브라우저에 쿠키가 저장되기 때문에)

* 쿠키(Cookie)
- '서버에 접근했다는 기록을 남기는 파일'
- 클라이언트에 저장된 서버의 정보를 포함하는 텍스트 '파일'
- 서버에 요청할 때 자동으로 Request 객체에 포함되어 전달
- 나에게 접속한 클라이언트가 들고 나르는 작은 파일
- 어느 사이트를 방문했다가 나오면 쿠키가 생겨있음
- 쿠키에 정보를 지울 수 있는 방법(시간 부여밖에 없음)
1. 타이머를 설정하면 언젠가 쿠키가 없어짐
2. 시간에 -1을 집어넣으면 브라우저를 닫을 때 쿠키가 갖고 있는 세션 아이디가 없어지기 때문에 쿠키가 없어짐
3. 시간을 부여하지 않으면 브라우저를 닫을 때 쿠키가 없어짐?

* 서버
- 서버가 보내준 쿠키를 보고 렌더링?
- 쿠키 저장할 때 서버 보내서 response에 저장시키고 다시 돌아오도록 만들기도 함

--- 면접 질문 ---

1. 쿠키의 정보를 보고 싶을 때 어떤 객체에서 가져올까요?
- request : 기존에 저장된 정보는 request에 담겨있기 때문에

2. 쿠키에 정보를 넣고 싶으면 어느 객체에서 가져올까요?
- response
- request에는 정보를 저장할 수 있는 setter가 없고 getter 느낌만 있음(왜?)

* 정리
- 클라이언트는 cookie에 정보를 저장할 수가 없음(서버 정보가 담겨있는 파일이기 때문에 클라이언트가 정보를 담을 이유가 없음)
- 녹음기의 기능이 cookie
- 서버가 클라이언트에게 던지는 객체가 response
- 인터넷 속도가 빨라졌기 때문에 사실상 클라이언트는 cookie가 있을 필요가 없음
- cookie의 유무에 따라 속도가 달라지기는 하는데 인간이 인지하지 못할 정도임
- 서버와 세션의 연결을 끊던가, 쿠키를 끊던가, 브라우저를 끄던가
- 조금 더 보호되어야 되는 정보는 세션에 저장해야 됨

* 요즘 쿠키 허용에 대한 질문을 하는 이유
- 개인정보보호법 때문에 cookie를 받을지 말지를 클라이언트가 정할 수 있음
- 크롬 시크릿모드를 이용하면 cookie가 쌓이지 않음

22:22
1. 세션은 서버 사이드에 데이터를 저장하기 위한 것이 아니라 클라이언트와 서버 간의 통신을 식별하기 위해서 만든 것
- 서버는 변경된 상태를 알 수 없기 때문에 클라이언트가 했던 동작들
- 기억하기 위해서?
2. 클라이언트가 서버에 방문했던 이력이 있을 경우 서버는 쿠키와 비교해서 변경된 정보만 내려주고
- 쿠키가 있는 것이 쿠키가 없는 것보다 브라우저의 반응 속도가 조금 더 빠름
- 쿠키는 파일 형태로 브라우저에 저장되기 때문에 오픈하기 쉽기 때문에 중요한 정보를 담으면 안됨
3.?

--- 2교시, 3교시 종료 ---



--- 2024-06-17 복습 시작 ---

* cookie & session
- 데이터를 저장하는 저장소
- session은 객체로 저장됨
- cookie는 파일로 저장됨
- session은 cookie에 저장됨
- cookie에 저장된 session은 정해진 시간이 없어서 session이 사라짐
- request 객체가 발생되면 request 객체는 cookie에 저장되어 전송됨
- 서버의 자원이 한정적이기 때문에 session은 cookie에 정보를 저장하고 올 때마다 돌려받는 경우가 좋음
- 예를들면 cookie의 로그인 정보가 있는 session을 삭제하면 로그인 상태가 해제됨

* HTTP only
- cookie는 HTTP 통신이 이루어질 때만 cookie에 저장된 데이터에 접근할 수 있음
- cookie에 보안 설정을 하기 위해서는 서로 request & response가 발생되어야만 접근을 허용함
- 따라서 JavaScript 등에서 직접 접근할 수가 없음

--- 2024-06-17 복습 종료---



- jstl 실습
- Servlet jsp 공부
- 수요일부터 Spring 시작

📌 21. 2024-06-18 강의
- 20240618-(정리완료)Servlet, MVC 수업

--- 2024-06-17 복습 시작 ---

* cookie & session
- 데이터를 저장하는 저장소
- session은 객체로 저장됨
- cookie는 파일로 저장됨
- session은 cookie에 저장됨
- cookie에 저장된 session은 정해진 시간이 없어서 session이 사라짐
- request 객체가 발생되면 request 객체는 cookie에 저장되어 전송됨
- 서버의 자원이 한정적이기 때문에 session은 cookie에 정보를 저장하고 올 때마다 돌려받는 경우가 좋음
- 예를들면 cookie의 로그인 정보가 있는 session을 삭제하면 로그인 상태가 해제됨

* HTTP only
- cookie는 HTTP 통신이 이루어질 때만 cookie에 저장된 데이터에 접근할 수 있음
- cookie에 보안 설정을 하기 위해서는 서로 request & response가 발생되어야만 접근을 허용함
- 따라서 JavaScript 등에서 직접 접근할 수가 없음

--- 2024-06-17 복습 종료---



--- jsp Servlet 학습 시작 ---

* JSP
- JSP는 아래와 같은 보안 및 프로그래밍 안정성의 문제가 있음
- 파일 하나에 서버 사이드와 클라이언트 사이드가 혼재되어 있음
- 그렇기 때문에 개발자의 실수 등으로 인한 각종 에러 발생 가능성이 더 높음
- 하나의 파일 안에 서버/클라이언트 코드가 작성되기 때문에 유지/보수가 어려움
- JSP의 소스 코드가 노출되기 때문에 서버 및 데이터베이스 정보 등 역시 노출됨
- 또한 웹 페이지가 JSP 파일로만 이동된다는 문제가 있었음(분리가 안되어 있었음)

--- jsp Servlet 학습 종료 ---



--- MVC 패턴 학습 시작 ---

### MVC 패턴 소개
> - Spring MVC는 Java EE의 Servlet API를 기반으로 구축된 웹 프레임워크입니다.
> - Spring MVC는 Model, View, Controller로 구분되며 이를 패턴이라고 합니다.
> - Model에는 데이터베이스, View에는 jsp, Controller에는 java 파일을 포함합니다.
> - Spring MVC는 DispatcherServlet이라는 중앙 서블릿을 사용하여 웹 요청을 처리합니다.
> - DispatcherServlet은 모든 웹 요청을 받아 적절한 컨트롤러로 라우팅하는 역할을 수행합니다.
> - DispatcherServlet이 등록되지 않은 경우 Spring MVC는 웹 요청을 처리할 수 없습니다.
> - DispatcherServlet 이외의 페이지는 ~

* MVC 패턴의 개발 과정
- JSP의 단점을 보완하기 위해 개발된 방식임
- 서버가 Model, View, Controller를 모두 보유(포함)하기 때문에 관리가 편함
- Model 담당 : 데이터베이스 객체
- View 담당 : JSP (Java Server Page)
- Control 담당 : Servlet

* MVC 패턴 실습
web-app
ㄴ java
ㄴ webContent
	ㄴWEB-INF
		ㄴview : 프론트엔드 파일 관리
			ㄴjsp : jsp 파일 관리
			ㄴhtml : html 파일 관리

* Servlet 개념
Controller 역할을 할 java 파일임
HTML, CSS, JS, JSP는 HTTP 통신이 가능함
Java 코드도 HTTP 통신이 가능해야 됨
HTTP 통신이 가능하게 하려면 상속 기능을 사용해야 됨
상속해야 될 것은 HttpServlet임
HttpServlet을 상속하면 HTTP 통신이 가능함
Servlet은 그냥 사용할 수가 없고 ServletMapping을 통해 주소를 부여해줘야 됨
Servlet을 생성했으면 Servlet을 등록해야 됨
Servlet을 등록하는 목적은 웹 서버가 어떤 요청을 어떤 Servlet에 전달해야 되는지 알 수 있도록 하는 것임
과거에는 web.xml에 일일이 직접적으로 등록했어야 됐었음
Servlet 3.0부터는 어노테이션으로 등록이 가능함
Servlet은 생명 주기를 갖고 있음(생명 주기 : 생성, 서비스, 소멸)

* 필수 메서드
- 추상 메서드를 오버라이드 또는 구현하는 것인가?
- doGet
- doPost
- init



--- 2024-06-19 22:53 정리 내용 ---
--- 2024-06-19 22:53 정리 내용 ---
--- 2024-06-19 22:53 정리 내용 ---



* 프로젝트 하나 당 톰캣 하나

* MVC 특징
- jsp에 직접 접근하지 못하게 막고 서버를 통해 접근하도록 만듦
- 클라이언트가 직접 접근하는 것이 아님
- 따라서 jsp 파일을 webContet 폴더에 생성하는 것이 아니라, WEB-INF 폴더에 생성함

* Controller의 페이지 이동 방법
- request를 이용한 forward 방식
- response를 이용한 redirect 방식
- forward : 사용자가 원하는 목적지로 이동시킴; 변화가 생김; 안끊고 계속(카드 분실 신고를 하러 전화했더니 분실 센터로 전화 돌리는 행위)
- redirect : 서버가 원하는 목적지로 이동시킴; 변화가 없음; break 후 다른 곳으로(전화번호 바뀌었으니 000으로 다시 연락하라고 하는 행위)
- 포워딩을 날린다 = forward

* parameter 객체
parameter 객체 : 클라이언트의 정보를 서버에 전송할 때 사용
getParameter : 클라이언트가 서버에게 준 데이터를 사용할 때
setAttribute : 서버가 클라이언트에게 준 데이터를 사용할 때(PageServlet.java에 예시)

--- MVC 패턴 학습 종료 ---



jsp → jstl → Servlet → MVC → MVC2

* MVC 1
- Spring은 Servlet으로 만들어짐
- 기존의 MVC 형태는 하나의 페이지에 2개 이상의 Servlet으로 구성되게 됨(서버가 많음)
- 그런데 서버가 많으면 session이 2번 이상 일어나게 됨

* MVC 2
- a라는 jsp는 하나의 class를 가짐
- b라는 jsp는 하나의 class를 가짐
- a, b를 DispatcherServlet이 관리함

📌 22. 2024-06-21 강의
- 20240621-(정리완료)Spring 동작 방식

### Spring
### Spring 개념
> - Spring의 작동 원리는 주요 개념인 IOC와 DI로 설명됩니다.

#### IOC (Iversion of Control)
> - Spring에게 제어권을 맡겨서 IOC의 대상으로 전환하는 어노테이션은 아래와 같습니다.
>    - @Controller : 명령문의 집합체
>    - @Restcontroller
>    - @Service : 명령문과 관련된 서비스 목적의 비즈니스 로직(Controller 전용)
>    - @Mapper : MyBatis
>    - @Repository : JPA
>    - @Component : 객체를 등록하는 것인데 사용자가 자주 사용하는 것이기에 등록/클래스에 붙임
>    - @Bean : 객체를 등록하는 것인데 기존의 존재하던 객체를 대체하기 위해 등록/메서드가 return하는 객체를 Bean 객체로 만듦
>    - @Configuration : Spring Boot에서 사용되는 어노테이션입니다.

#### DI (Dependency Injection)

--- 1,2교시 ---

* Spring 주요 개념
- 제어의 역전(IOC; Inversion of Control)
- 기존에는 개발자가 객체의 생성/사용/소멸과 같은 프로그래밍 제어를 하였음
- Spring에서는 프로그램이 프로그래밍 제어의 주도권이 개발자가 아니라 Spring에게 있음
- 어떤 경로에 어느 객체를 사용하고 어느 객체끼리 연결해야될지
- 빈 껍데기를 생성함

- 의존성 주입(DI; Dependency Injection)
- IOC가 된 것만 DI할 수 있음

- IOC는 일부 객체를 생명주기와 효율성을 위해서 개발자가 아닌 프로그램에게 위임함으로써 프로그램 개발 효율성을 증대시킨 것임
- DI는 제어의 역전을 통해 관리되는 객체 중에 프로그램 실행 중 부여하는 기능임

* Spring 동작 방식
- DispatcherServlet이 목록을 가지고 있음
- 효율성을 위해 DispatcherServlet은 실행 대상 메서드를 '자동으로' 스캔함
- 대신 컴퓨터의 비용으로 비유되는 메모리 사용량이 증가하기 때문메 메모리 할당량을 최대로 설정하면 좋음
- 스캔 대상은 Controller
- Servlet마다 경로가 있고 해당 경로를 입력하면 해당 Servlet이 데이터를 가져옴

* xml 구조
- <insert></>
- <select></>
- <update></>
- <delete></>



2024-06-23 23:13 정리
2024-06-23 23:13 정리
2024-06-23 23:13 정리



* MyBatis
- @Mapper, @Repository을 읽어감
- MyBatis에는 trigger가 입력되어 있음
- 연결고리를 찾아야 됨
- 실행할 메서드명과 동일한 데이터베이스 ID의 아이디가 일치해야 됨

* @Service
- 명령문과 관련된 서비스 목적의 비즈니스 로직(Controller 전용)
- Service를 만들어야 되는 이유는 Controller가 다르더라도 서비스 방식이 일관되어야 될 때가 있기 때문임

* Spring의 핵심 어노테이션
Controller, Service, Mapper

* RequestMapping
- 따로 GET/POST 설정을 안하면 두 방식의 요청을 모두 받아들임

Spring 5 이전
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller
public class HelloController {
	
	// GET/POST 모두 수용
	// @RequestMapping(value="/hello.do")
	// only GET 수용
	@RequestMapping(value="/hello.do", method = RequestMethod.GET)
	// only POST 수용
	// @RequestMapping(value="/hello.do", method = RequestMethod.POST)
	public String hello() {
		return "hello";
	}

}

Spring 5 이후
PostMapping
GetMapping

* .do 인데도 나오는 이유
- web.xml에서 URL 패턴에 .do 접미어가 붙으면 해당 패턴을 가진 모든 요청이 DispatcherServlet을 통해 처리되도록 설정했기 때문입니다.

--- 1,2교시 동안 개념 설명 ---



--- Java 파일 출력 ---

* 데이터 입출력 관련
- 컴퓨터는 무조건 input과 output이 존재함
- input은 입력받는 것
- output은 출력하는 것
- 읽는 것 read, 쓰는 것 write
- 들어오는 것 : input stream
- 나가는 것 : output stream

* 과거 데이터 저장 방식
- 파일에 저장했음
- 객체를 통(data stream, object stream)으로, 잘라서(data array, byte array), byte input byte output

* 현재 데이터 저장 방식
- 데이터베이스에 저장

* Byte 기반
- 비영어권 문자 깨짐 현상이 있음
** File input
** File output

* Character 기반
- 문자 기반은 많이 사용 안함
** FileReader
** FileWriter

📌 23. 2024-06-20 강의
- 20240620-(정리완료)Lombok, MyBatis, Framework 실습 수업

* 웹 기본 지식
- Request 객체
- Response 객체
- Session
- Cookie
- Parameter 객체
- Attribute
- 이를 총 망라해서 하나의 프레임워크로 형성시킨 것이 Spring입니다.

--- 1교시 ---

* Spring을 학습하는 방식
- Spring 세팅은 파일 다운로드 함
- 어차피 회사 가면 Spring 세팅할 일이 당분간 없음
- 대신 Spring Boot는 세팅할줄 알아야 됨

* jar
- 반디집 설정 - 환경 설정에서 기타 압축 파일, CD 등 다 풀어줘야 됨

* Lombok
- getter/setter 자동으로 만들어줌
- 생성자 등도 간단한 @ 추가로 생성됨
- STS4에 설치할 수 있음
- Lombok 다운로드 사이트 및 방법
- https://projectlombok.org/download
- Lombok jar 파일 다운로드 및 실행 후 원하는 STS 선택 또는 위치 선택 후 Install하면 끝남
- root의 SpringToolSuite.ini에서 'javaagent:C:\koreait\sts-4.23.0.RELEASE\lombok.jar'가 추가되었을 것임
https://projectlombok.org/download

### Lombok
> - Lombok은 웹 개발을 보다 편리하게 할 수 있도록 돕는 프로그램입니다.

* Package Explorer
- Window - Show View - Other - Package Explorer 검색

### Maven Project 생성 요령
- Create Simple Project 체크
- Group id: kr.com

### Maven Project
> - 프로그램 형상 관리 툴입니다.(프로그램 관리)
> - JSON 기반으로 구성된 프로젝트입니다.
> - Spring Framework

### Gradle Project
> - 프로그램 형상 관리 툴입니다.(프로그램 관리)
> - 무슨 기반으로 구성된 프로젝트입니다.
> - 속도가 빠르기 때문에 안드로이드 개발 등에 사용됩니다.
> - Spring Boot

### Maven vs Gradle
> - Gradle은 Maven 상속 받고 구성된 것입니다.
> - Maven json 기반 Gradle은?
> - pom.xml에 등록되어 있는 내용을 IDE에서 자동으로 다운로드 받아줍니다.

* filter vs interceptor
- interceptor는 나갈 때 등 출입 금지
- filter는 입구에서 출입 금지
- 사실상 개념적인 내용

### Spring 세팅 방법

### Java 당시
> - 연결을 하기 위해 아래와 같은 코드를 입력하였었습니다.
> - Connection conn = DriverManager.getConnection(주소, id, pwd);
> - preparedStatementPstmt = ~
> - ResultSet res = pstmt.excuteQeury();
> - 1 대 1로 데이터베이스를 달라고 하면 커넥션 맺고 쿼리 날리고 하는 방식임(키오스크 주문과 비슷함)
> - 하지만 웹에서 데이터베이스 접근 관련은 1 대 수천 이상임

### DBCP
> - DBCP는 Database Connection Pool의 축약어이며 데이터베이스 커넥션을 포함하는 풀입니다.
> - 최소, 최대, 딜레이 개념이 있습니다.

### JDBC

### MyBatis
> - MyBatis의 역할은 데이터를 연결해주고 ~ SQL 연결해주고 등등입니다.
> - MyBatis는 JDBC API를 이용하여 DB에 접근합니다.
> - SqlSession은 연결이 되었기 때문에 생긴 것입니다.
> - dataSource는 DB에 연결하는 객체입니다.

### prefix suffix
> - 우리가 html, jstl을 쓸지 등을 모르기 때문에 거기에 맞춰서 띄워줄게를 의미합니다.

📌 24. 2024-06-10 강의
- 20240610-(정리완료)웹 개발 개념

---1교시---

* 웹 개발 기본 지식
1. JSP(2024-06-11 강의에서 개념 정리)
2. Servlet
(Spring Framework 내용은 잘 없음)
3. Spring
- JSP 등의 지식이 기본적으로 탑재됐을 것이라는 판단
- 더 이상 지원되지 않음

* ?
JPA는 뭐지?

* Spring을 배워야 하는 이유
우리는 왜 Spring을 배워야 하는가?
- Spring으로 개발된 서비스가 많음
- 신입으로 들어가면 유지보수를 먼저 함
- 그래서 legacy 지식이 필요함
- Spring Framework를 잘하면 Spring Boot를 잘 할 수밖에 없음

* 관련성
- Spring이 이해가 안되면 Java 지식(서버는 따로)
- React가 이해가 안되면 JavaScript 지식

* 공문서
1. HTML
- 태그 구조로 되어 있는 Markup Language
2. XML : 데이터 + 설명서
- 태그 구조로 되어 있는 Markup Language
- 국제 표준 데이터 구조 document
- 요즘에는 JSON 데이터 구조를 사용함
- 요즘에 XML을 안쓰는 이유
-- 문서가 태그 구조로 되어있기 때문에 = 문서가 트리 구조이기 때문에 = 문서가 복잡하기 때문에
-- DATASET을 가져오기 위한 탐색 시간이 꽤 오래 걸림 = 일부러 그렇게 만듦 = 사용자가 쉽게 가져가지 못하게 하려고

📌 25.
📌 26.
📌 27.
📌 28.
📌 29.
📌 30.











